\documentclass[11pt]{article}
\title{\textbf{Relazione sul progetto chatterbox}}
\author{Gioele Bertoncini}
\date{}
\begin{document}

\maketitle

\section{Struttura del server}
\subsection{Strutture dati}

\subsubsection{Tabella degli utenti}
La struttura principale che tiene traccia delle informazioni sugli utenti del server \`e definita dal tipo \emph{users\_table\_t} definita e implementata nei file \emph{users\_table.h} e \emph{users\_table.c}. Al suo interno memorizza i dati relativi a gruppi e utenti in due tabelle hash (la cui implementazione si trova nei file \emph{icl\_hash.h} e \emph{icl\_hash.c}, entrambi forniti durante il corso). La prima tabella hash contiene elementi di tipo \emph{chat\_user} che modellano un singolo utente registrato, composti da un array di caratteri per rappresentare il nickname, un intero che indica il numero del file descriptor su cui l'utente è attualmente connesso e una coda dei messaggi ricevuti dall'utente (vedi 1.1.2). La seconda tabella contiene la lista dei gruppi creati dagli utenti, rappresentati dalla struttura \emph{chat\_group} che \`e composta da due array di caratteri (nickname del proprietario e nome del gruppo) e dalla lista dei membri del gruppo (vedi 1.1.3).

La tabella degli utenti fa uso anche di un array di n+m+f mutex per sincronizzarsi rispettivamente su utenti, gruppi e descrittori di file, l'indice con cui vi si accede \`e calcolato applicando la stessa funzione usata per le tabelle hash modulo n, m o f (nel caso dei dei descrittori viene usato direttamente il valore) . Le prime n posizioni sono riservate alle mutex per gli utenti e le successive m a quelle per i gruppi, in questo modo sono maggiori le possibilià di eseguire più operazioni contemporaneamete. Le procedure per ottenere e rilasciare le lock sono implementate utilizzando alcune macro, in particolare \emph{LOCKINORDER} e \emph{UNLOCKINORDER} confrontano i valori di due nomi in modulo per acquisire/rilasciare le lock in ordine corretto, \emph{LOCKALL} e \emph{UNLOCKALL} acquisiscono/rilasciano tutte le lock dell'array in sequenza.

\subsubsection{Code di messaggi, richieste e descrittori}
Il server utilizza 3 tipi di code, tutte definite in \emph{queue.h} e \emph{queue.c} (i due file sono quelli forniti dai docenti durante il corso, modificati opportunamente togliendo la sincronizzazione interna e aggiungendo una funzione per liberare la memoria). Ogni utente (\emph{chat\_user\_t}) ha una coda di messaggi che rappresenta la sua history, ogni thread worker fa uso inoltre di una coda di interi per ricordarsi i file descriptor a cui deve inviare i messaggi broadcast. L'ultima coda è usata per inviare richieste dal thread \emph{listener} ai \emph{worker} e contiene elementi di tipo \emph{request\_t} composti da un messaggio e un descrittore di file.

\subsubsection{Lista dei membri di un gruppo}
Per ogni gruppo registrato sul server viene mantenuta la lista dei membri, implementata come linked list di stringhe dai file \emph{string\_list.h} e \emph{string\_list.c}. Per inviare messaggi o file ai membri di un gruppo si recuperano i loro nomi attraverso la funzione \emph{getByIndex} che permette di accedere agli elementi della lista tramite indice. Per evitare di appesantire l'operazione di deregistrazione di un utente, quest'ultimo non viene cancellato immediatamente dai gruppi di cui era membro. Il controllo e l'eventuale rimozione viengono fatti durante l'invio di messaggi a un gruppo.

Questa lista \`e inoltre utilizzata per tenere traccia degli utenti online e dei rispettivi file descriptors, \`e necessaria nel caso in cui il thread \emph{listener} (vedi 1.2) decide di chiudere una connessione ma conosce solo il file descriptor su cui l'utente \`e connesso e non il suo nickname.

\subsection{Threads}
Il server utilizza 1 thread per gestire i segnali \emph{signal\_handler} che si sospende con la \emph{sigwait}, 2 thread per gestire le connessioni: il thread \emph{dispatcher} che esegue in un ciclo infinito la accept e segnala ogni nuovo file descriptor al thread \emph{listener} che esegue una select per trovare quali descrittori di file sono pronti per essere letti. Da questi vengono lette le richieste dei client che vengono inserite nella coda \emph{pendingRequests}. Infine viene attivato un pool di thread \emph{workers} i quali estraggono e elaborano le richieste e rispondono opportunamente ai client. I thread del server comunicano tra di loro attraverso una pipe dove i \emph{workers} e il \emph{dispatcher} producono file descriptors e il \emph{listener} li consuma.

\subsection{Chat Parser}
Il main fa anche uso delle funzioni fornite da \emph{chat\_parser.h} e \emph{chat\_parser.c} per recuperare dal file di configurazione le informazioni necessarie per il funzionamento del server. In aggiunta a quelle gi\`a previste dal kit del progetto sono state aggiunte:

\begin{tabular}{ll}
	\textbf{UserLocks} & Numero di mutex utilizzate per sincronizzarsi sugli utenti\\
	\textbf{GroupLocks} & Numero di mutex utilizzate per sincronizzarsi sui gruppi\\
	\textbf{FdLocks} & Numero di mutex utilizzate per sincronizzarsi sui descrittori\\
	\textbf{Buckets} & Numero di buckets per le tabelle hash\\
\end{tabular}

\section{Terinazione del server}
Quando il thread \emph{signal\_handler} riceve il segnale SIGUSR1 scrive un -1 sulla pipe del \emph{listener}, quando quest'ultimo lo legge invia n messaggi con operazione OP\_END sulla coda dove n \`e il numero dei thread \emph{worker}, il thread \emph{dispatcher} viene cancellato.

\section{Sincronizzazione}
Oltre alla sincronizzazione interna alla tabella degli utenti (vedi 1.1.1), i thread fanno uso di altre 2+n mutex: una per sincronizzarsi sulla pipe, una per sincronizzarsi sulla coda delle richieste e un array di n per sincronizzarsi sui descrittori durante le operazioni di write e read.

\section{Script bash}
Lo script bash si serve dei comandi cut e grep per selezionare il pattern corrispondene e di tr per eliminare spazi e tab. Inoltre utilizza il comando find per eliminare i file pi\`u vecchi.
\section{Sviluppo del codice}
Tutto il codice è stato sviluppato utilizzando \emph{gedit}, compilato e testato tramite il Makefile fornito nel kit del progetto.
\section{Note}
Nel file \emph{icl\_hash.c} nella funzione di eliminazione di un elemento il contatore degli oggetti contenuti nella tabella hash veniva incrementato anzich\`e ridotto.
Nell'implentazione della tabella degli utenti c'\`e anche una funzione per l'eliminazione dei gruppi, non viene mai usata dai test.
\end{document}

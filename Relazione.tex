\documentclass[11pt]{article}
\title{\textbf{Relazione sul progetto chatterbox}}
\author{Gioele Bertoncini}
\date{}
\begin{document}

\maketitle

\section{Struttura del server}
\subsection{Strutture dati}

\subsubsection{Tabella degli utenti}
La struttura principale che tiene traccia delle informazioni sugli utenti del server è definita dal tipo \emph{users\_table\_t} definita e implementata nei file \emph{users\_table.h} e \emph{users\_table.c}. Al suo interno memorizza i dati relativi a gruppi e utenti in due tabelle hash (la cui implementazione si trova nei file \emph{icl\_hash.h} e \emph{icl\_hash.c}, entrambi forniti durante il corso. La prima tabella hash contiene elementi di tipo \emph{chat\_user} che modellano un singolo utente registrato, composti da un array di caratteri per rappresentare il nickname, un intero che indica il numero del file descriptor su cui l'utente è attualmente connesso e una lista dei messaggi ricevuti dall'utente (vedi 1.1.2). La seconda tabella contiene la lista dei gruppi creati dagli utenti, rappresentati dalla struttura \emph{chat\_group} che è composta da due array di caratteri (nickname del proprietario e nome del gruppo) e dalla lista dei membri del gruppo (vedi 1.1.3).

La tabella degli utenti fa uso anche di un array di n+m mutex per sincronizzarsi su utenti e gruppi, l'indice con cui vi si accede è calcolato applicando la stessa funzione usata per le tabelle hash modulo n o m . Le prime n posizioni sono riservate alle mutex per gli utenti e le successive m a quelle per i gruppi, in questo modo sono maggiori le possibilià di eseguire più operazioni contemporaneamete. Le procedure per ottenere e rilasciare le lock sono implementate utilizzando alcune macro, in particolare \emph{LOCKINORDER} e \emph{UNLOCKINORDER} confrontano i valori di due nomi in modulo per acquisire/rilasciare le lock in ordine corretto, \emph{LOCKALL} e \emph{UNLOCKALL} acquisiscono/rilasciano tutte le lock dell'array in sequenza.

\subsubsection{Lista dei messaggi}
Il server mantiene per ogni utente una lista di messaggi (che possono essere testuali o nomi di file) lunga al più MaxHistMsg (specificata nel file di configurazione). La struttura di questa  history è una linked list e si trova nei file \emph{msg\_list.h} e \emph{msg\_list.c}, per ogni messaggio si mantengono due stringhe (contenuto o nome di file e mittente), e due interi (stato di cosegna e tipo). Se viene raggiunto il numero massimo di messaggi memorizzabili si elimina il messaggio più vecchio. L'interfaccia fornisce la funzione \emph{getMsgList} che restituisce una copia dei messaggi non ancora recapitati al destinatario.

\subsubsection{Lista dei membri di un gruppo}
Per ogni gruppo registrato sul server viene mantenuta la lista dei membri, implementata come linked list di stringhe dai file \emph{string\_list.h} e \emph{string\_list.c}. Per inviare messaggi o file ai membri di un gruppo si recuperano i loro nomi attraverso la funzione \emph{getByIndex} che permette di accedere agli elementi della lista tramite indice. Per evitare di appesantire l'operazione di deregistrazione di un utente, quest'ultimo non viene cancellato immediatamente dai gruppi di cui era membro. Il controllo e l'eventuale rimozione viengono fatti durante l'invio di messaggi a un gruppo.

Questa lista è inoltre utilizzata per tenere traccia degli utenti online e dei rispettivi file descriptors, è necessaria nel caso in cui il thread \emph{listener} (vedi 1.2) decide di chiudere una connessione ma conosce solo il file descriptor su cui l'utente è connesso e non il suo nickname.

\subsection{Threads}
Il server utilizza 1 thread per gestire i segnali \emph{signal\_handler} che si sospende con la \emph{sigwait}, 2 thread per gestire le connessioni: il thread \emph{dispatcher} che esegue in un ciclo infinito la accept e segnala ogni nuovo file descriptor al thread \emph{listener} che esegue una select per trovare quali descrittori di file sono pronti per essere letti. Da questi vengono lette le richieste dei client che vengono inserite nella coda \emph{pendingRequests}. Infine viene attivato un pool di thread \emph{workers} i quali estraggono e elaborano le richieste e rispondono opportunamente ai client. I thread del server comunicano tra di loro attraverso una pipe dove i \emph{workers} e il \emph{dispatcher} producono file descriptors e il \emph{listener} li consuma.

\subsection{Chat Parser}
Il main fa anche uso delle funzioni fornite da \emph{chat\_parser.h} e \emph{chat\_parser.c} per recuperare dal file di configurazione le informazioni necessarie per il funzionamento del server. In aggiunta a quelle già previste dal kit del progetto sono state aggiunte:
\begin{tabular}{ll}
	UserLocks & Numero di mutex utilizzate per sincronizzarsi sugli utenti\\
	GroupLocks & Numero di mutex utilizzate per sincronizzarsi sui gruppi\\
	FdLocks & Numero di mutex utilizzate per sincronizzarsi sui descrittori\\
	Buckets & Numero di buckets per le tabelle hash\\
\end{tabular}


\section{Script bash}
Lo script bash si serve dei comandi cut e grep per selezionare il pattern corrispondene e di tr per eliminare spazi e tab. Inoltre utilizza il comando find per eliminare i file più vecchi.
\section{Sviluppo del codice}
Tutto il codice è stato sviluppato su \emph{Fedora 27}, compilato e testato tramite il Makefile fornito nel kit del progetto.
\end{document}
